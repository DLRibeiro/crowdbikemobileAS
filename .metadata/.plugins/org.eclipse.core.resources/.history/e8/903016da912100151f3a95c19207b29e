package com.software.project.amqp;

import java.io.IOException;
import java.util.HashMap;

import org.apache.commons.lang.SerializationUtils;
import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.MessageListener;
import org.springframework.amqp.core.Binding.DestinationType;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.core.MessageBuilder;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.ErrorHandler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


@Service("messageQueueManager")
public class MessageQueueManagerImpl implements MessageQueueManager{
@Autowired
private AmqpAdmin admin;
@Autowired
private AmqpTemplate template;
@Autowired
private ConnectionFactory connectionFactory;
@Autowired
private SimpleMessageListenerContainer container;
/** Logger */
private static Logger Log = LoggerFactory.getLogger(MessageQueueManagerImpl.class);

@Override
public String createQueue(String queueName) {
	
	 if(admin.getQueueProperties(queueName) == null){	
			
			
		   Log.debug("creating queue with name: " + queueName);
			
		   //create queue
		   Queue newQueue = new Queue(queueName,true,false,false);
		   admin.declareQueue(newQueue);
		   
		  
		   //create binding with exchange
		//   admin.declareBinding(new Binding(queueName, DestinationType.QUEUE, "directExchange", queueName, new HashMap<String,Object>()));

		   Log.debug("queue successfully created: " + queueName);
		   
		   //add queue to listener
		   container.setQueues(newQueue);

		   //start listener
		   container.start();
		   }
		   return queueName;
}
@Override
public void sendMessage(String message,String destinationQueueName) throws Exception {
  // template.convertAndSend("directExchange", destinationQueueName,   MessageBuilder.withBody(message.getBytes()).build());
  	template.convertAndSend("", destinationQueueName,  SerializationUtils.serialize(message));
	
}

@Override
public void onMessage(Message message) {
 //  Log.debug(new String(message.getBody()));
}


@Override
//metodo para consumir fila --- testar essa poxaaa!!
public void Consume(String endPointName) throws IOException{
	   //create queue
	   Queue newQueue = new Queue(endPointName,true,false,false);
	   admin.declareQueue(newQueue);

	   //add queue to listener
	   container.setQueues(newQueue);
	   final SimpleMessageListenerContainer listenerContainer = new SimpleMessageListenerContainer();
	   container.setMessageListener(listenerContainer);
	   
	   // set the callback for message handling
	    listenerContainer.setMessageListener(new MessageListener() {
	     	@Override
				public void onMessage(Message message) {
					// TODO Auto-generated method stub
	     		String messageBody= new String(message.getBody());
	             // simply printing out the operation, but expensive computation could happen here
	             System.out.println("Received from RabbitMQ: " + messageBody);
				}
	     });
	
	     // set a simple error handler
	     listenerContainer.setErrorHandler(new ErrorHandler() {
	     	@Override
	         public void handleError(Throwable t) {
	             t.printStackTrace();
	         }
	     });
	
	     // register a shutdown hook with the JVM
	     Runtime.getRuntime().addShutdownHook(new Thread() {
	         @Override
	         public void run() {
	             System.out.println("Shutting down BigOperationWorker");
	             listenerContainer.shutdown();
	         }
	     });
	
		   //start listener
		   container.start();


}



}